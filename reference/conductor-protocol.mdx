---
title: "The Conductor Protocol"
description: "AI-Compiled Flow Execution via Collapse, Extract, Parallelize, Converge, and Tesseract â€” a novel architecture that treats workflow graphs as blueprints of intent and compiles them into optimized execution strategies."
sidebarTitle: "The Conductor Protocol"
---

# The Conductor Protocol

**AI-Compiled Flow Execution â€” Collapse, Extract, Parallelize, Converge, Tesseract**

*Open source (MIT). Part of the OpenPawz project.*

---

## The Problem

Every workflow automation platform â€” n8n, Zapier, Make, Prefect, Airflow â€” executes the same way: walk the graph, node by node, in topological order. Node A finishes, pass data to Node B, Node B finishes, pass data to Node C. Sequential. Synchronous. One LLM call per agent node.

This worked fine when workflows were simple and nodes were cheap API calls. But AI workflows are fundamentally different:

- **Agent nodes are expensive.** Each agent step is an LLM call â€” 2â€“10 seconds of latency and real token cost.
- **Chains get long.** A real pipeline might have 8â€“20 nodes: trigger â†’ parse data â†’ agent analysis â†’ condition â†’ agent rewrite â†’ tool call â†’ agent review â†’ output.
- **Branches are wasted.** When two independent branches can run in parallel, sequential execution waits for each one to finish before starting the next.
- **Cycles are impossible.** n8n, Zapier, and Make all require DAGs â€” directed acyclic graphs. No loops, no feedback, no iterative refinement. If you need two agents to debate until they agree, you can't express that.

### The math is simple and brutal

A 10-node flow with 6 agent steps, each averaging 4 seconds of LLM latency:

| Platform | Execution | Time | LLM Calls |
|----------|-----------|------|-----------|
| n8n / Zapier / Make | Sequential walk | **24s+** | 6 |
| OpenPawz (Conductor) | Compiled strategy | **4â€“8s** | 2â€“3 |

The Conductor doesn't skip work. It does the same work *smarter* â€” merging compatible agent calls, running independent branches simultaneously, and bypassing the LLM entirely for nodes that don't need it.

---

## The Invention

The Conductor Protocol treats flow graphs not as programs to execute, but as **blueprints of intent** that can be compiled into optimized execution strategies before a single node runs.

Traditional platforms interpret flows imperatively â€” "do this, then this, then this." The Conductor interprets flows declaratively â€” "here is what needs to happen; let me figure out the fastest way to make it happen."

The compilation step produces an `ExecutionStrategy`: a sequence of phases, where each phase contains units that run concurrently, and each unit represents one or more original nodes merged or classified for optimal execution.

### Five Primitives

The Conductor analyzes any flow graph and applies five optimization primitives:

```mermaid actions={false}
graph TD
    subgraph Input["Flow Graph (Blueprint)"]
        A["trigger"] --> B["agent 1"]
        B --> C["agent 2"]
        B --> D["agent 3"]
        C --> E["tool"]
        D --> F["code"]
        E --> G["agent 4"]
        F --> G
    end

    subgraph Conductor["Conductor Compilation"]
        H["1. Collapse â€” merge compatible agents"]
        I["2. Extract â€” bypass LLM for deterministic nodes"]
        J["3. Parallelize â€” run independent branches concurrently"]
        K["4. Converge â€” handle cycles with iterative rounds"]
        K2["5. Tesseract â€” orchestrate cells across dimensions"]
    end

    subgraph Output["Execution Strategy"]
        L["Phase 0: trigger (passthrough)"]
        M["Phase 1: collapsed(agent1+agent2) â€– collapsed(agent1+agent3)"]
        N["Phase 2: direct(tool) â€– direct(code)"]
        O["Phase 3: single-agent(agent4)"]
    end

    Input --> Conductor
    Conductor --> Output
```

---

## Primitive 1: Collapse

**Adjacent agent nodes with compatible configurations merge into a single LLM call.**

When two or three agent nodes form a chain â€” each passing output to the next â€” the Conductor merges their prompts into a single compound prompt with step boundaries. One LLM call does the work of many.

### Before (traditional):

```
Agent 1: "Summarize this data"        â†’ LLM call (4s)  â†’ result
Agent 2: "Extract key metrics fromâ€¦"  â†’ LLM call (4s)  â†’ result
Agent 3: "Write a report based onâ€¦"   â†’ LLM call (4s)  â†’ result
Total: 3 LLM calls, ~12 seconds
```

### After (Conductor Collapse):

```
Collapsed prompt:
  "Step 1: Summarize this data
   ---STEP_BOUNDARY---
   Step 2: Extract key metrics from the summary above
   ---STEP_BOUNDARY---
   Step 3: Write a report based on the metrics above"
â†’ 1 LLM call (5s) â†’ parsed back into 3 node outputs
Total: 1 LLM call, ~5 seconds
```

#### Compatibility rules

Two agent nodes can be collapsed when they:
- Share the same model (or both use the default model)
- Share the same temperature setting (or both use defaults)
- Have no tool invocations configured (tool calls require individual sessions)
- Form a direct chain (A â†’ B) with no branching between them

The Conductor detects these chains automatically via `detectCollapseChains()` and builds merged prompts via `buildCollapsedPrompt()`. After execution, `parseCollapsedOutput()` splits the response back into individual node results using `---STEP_BOUNDARY---` delimiters.

---

## Primitive 2: Extract

**Deterministic nodes bypass the LLM entirely and execute directly.**

Not every node in an AI workflow needs artificial intelligence. Tool calls, HTTP requests, code execution, data transforms, and MCP invocations are fully deterministic â€” they don't need an LLM to format a JSON-RPC call or run a JavaScript function. The Conductor classifies each node and routes deterministic work to direct execution:

| Node Classification | Execution Path | Examples |
|---------------------|---------------|----------|
| **Agent** | LLM call via engine | `agent`, `squad` |
| **Direct** | Bypass LLM â€” execute via Rust backend or sandbox | `tool`, `code`, `http`, `mcp-tool`, `loop`, `memory`, `memory-recall` |
| **Passthrough** | No execution â€” data forwarding only | `trigger`, `output`, `error`, `group` |

In a 10-node flow with 4 agent nodes and 6 direct/passthrough nodes, the Conductor reduces LLM calls from 10 to 4 â€” or fewer, if some agents can be collapsed.

### How Extract works with the Foreman Protocol

Extract and the [Foreman Protocol](/reference/foreman-protocol) are complementary optimizations that operate at different levels:

- **Extract** eliminates unnecessary LLM calls at the *flow level* â€” a tool node in a flow doesn't need any model to execute
- **Foreman** reduces the cost of necessary tool calls at the *agent level* â€” when an agent decides to call a tool during conversation, the Foreman delegates to a cheaper model

Together: the Conductor skips the LLM for deterministic flow nodes entirely, and when agent nodes do need to call tools, the Foreman handles execution at minimal cost.

---

## Primitive 3: Parallelize

**Independent branches at the same depth level execute concurrently.**

When a flow fans out â€” one node feeding into multiple downstream branches that don't depend on each other â€” sequential execution wastes time waiting for each branch to finish before starting the next. The Conductor detects independent branches via depth analysis and union-find grouping, then runs them simultaneously within the same execution phase.

```mermaid actions={false}
graph LR
    A["trigger"] --> B["agent: classify"]
    B --> C["agent: summarize"]
    B --> D["tool: fetch metrics"]
    B --> E["code: parse data"]
    C --> F["output"]
    D --> F
    E --> F
```

### Sequential (traditional):
```
trigger â†’ classify â†’ summarize â†’ fetch metrics â†’ parse data â†’ output
Total: 6 steps, ~16 seconds
```

### Conductor (parallel):
```
Phase 0: trigger (passthrough)
Phase 1: classify (single agent)
Phase 2: summarize â€– fetch metrics â€– parse data  â† all three run concurrently
Phase 3: output (passthrough)
Total: 4 phases, ~8 seconds
```

The grouping algorithm uses `groupByDepth()` to assign each node a depth level based on its longest path from roots, then `splitIntoIndependentGroups()` uses union-find to identify which nodes within the same depth level share dependencies. Nodes in separate dependency groups run as concurrent execution units within the same phase.

---

## Primitive 4: Converge (Convergent Mesh)

**Cyclic subgraphs iterate as shared-context conversations until outputs stabilize.**

This is the primitive that has no equivalent in any existing workflow platform. n8n, Zapier, Make, Airflow, Prefect â€” they all require DAGs. Cycles are errors. Feedback loops are impossible.

But some of the most powerful AI patterns are inherently cyclic:

- **Debate and consensus:** Two agents argue a topic until they reach agreement
- **Iterative refinement:** A writer and editor pass drafts back and forth until quality stabilizes
- **Self-correction:** An agent checks its own output, finds errors, fixes them, checks again
- **Multi-perspective analysis:** Three analysts each review the others' findings and update their own

The Conductor enables these patterns through **bidirectional edges** and convergent mesh execution.

### How it works

```mermaid actions={false}
graph LR
    A["agent: writer"] <-->|"bidirectional"| B["agent: editor"]
    A --> C["output: final draft"]
```

1. The Conductor detects cycles in the flow graph (nodes connected via bidirectional or reverse edges that form loops)
2. Overlapping cycles are merged into **mesh groups** via `buildMeshConfigs()`
3. Each mesh group executes in iterative rounds:
   - Round 1: Each node in the mesh executes with its initial input
   - Round 2: Each node re-executes with shared context from all other nodes' Round 1 outputs
   - Round N: Continue until outputs **converge** or max iterations are reached
4. **Convergence detection** uses Jaccard similarity on word tokens â€” when consecutive outputs from the same node are â‰¥85% similar, that node has stabilized
5. When all nodes in the mesh have converged, or the maximum iteration count (default: 5) is reached, the mesh completes and downstream nodes receive the final outputs

### Example: Writerâ€“Editor debate

```
Round 1:
  Writer: produces initial draft
  Editor: reviews draft, suggests changes

Round 2:
  Writer: revises based on editor feedback
  Editor: reviews revision â€” "much better, minor grammar fix on paragraph 3"

Round 3:
  Writer: applies grammar fix
  Editor: reviews â€” "looks good, approved"  â† 92% similar to Round 2 output

Convergence detected (0.92 > 0.85 threshold). Mesh complete.
Output: final approved draft flows to downstream nodes.
```

No other automation platform can express this pattern. In n8n, you would need to manually build a loop with external state management and hope it terminates. In Zapier, it's simply impossible.

---

## Primitive 5: Tesseract (Hyper-Dimensional Flows)

**Parallel workflow cells operating across depth and phase dimensions, converging at event horizons.**

Primitives 1â€“4 operate on a flat graph â€” sequence (X) and parallelism (Y) on a 2D canvas. But the Conductor already works in higher dimensions implicitly. When a convergent mesh iterates, each round is a distinct state â€” the same topology executing with accumulated context. When parallel branches run independently before merging, they occupy separate "spaces" that collapse at a join point.

The Tesseract primitive makes these hidden dimensions explicit and controllable.

### The four dimensions of a workflow

| Dimension | Axis | Represents | Example |
|-----------|------|-----------|---------|
| **1st** (X) | Sequence | Step ordering, causality | A â†’ B â†’ C |
| **2nd** (Y) | Parallelism | Concurrent branches, condition splits | A â†’ {B â€– C} â†’ D |
| **3rd** (Z) | Depth | Iteration layers, abstraction nesting, sub-flow stacking | Mesh round 1 â†’ round 2 â†’ round 3 (helix, not loop) |
| **4th** (W) | Phase | Behavioral mode shifts as context accumulates | Exploration â†’ Refinement â†’ Convergence â†’ Crystallized |

A standard flow is a 2D projection (X Ã— Y). A convergent mesh is a 3D helix (X Ã— Y Ã— Z). A tesseract flow is the full 4D object (X Ã— Y Ã— Z Ã— W) â€” independent workflow cells that can operate in parallel across all four dimensions, connecting only at designated **event horizons** where they synchronize and merge.

### Cube-in-cube: the Schlegel diagram

A tesseract (4D hypercube) has 8 cubic cells. When projected into 2D for display, it appears as a **cube inside a cube** â€” the Schlegel diagram. In workflow terms:

```mermaid actions={false}
graph TD
    subgraph Outer["â—» Cell W=0 â€” Exploration"]
        C["ğŸ” Agent C\n(research)"] --> D["ğŸ“Š Agent D\n(classify)"]
        subgraph Inner["â—» Cell W=1 â€” Refinement"]
            A["ğŸ§  Agent A\n(analyst)"] <-.-> B["ğŸ§  Agent B\n(critic)"]
        end
    end
    D --> H{"â¬¡ Event Horizon"}
    B --> H
    H --> Next["âœ¦ Merged Output\nW â†’ 2 (Convergence)"]
    style Outer fill:#1a1a2e,stroke:#8b5cf6,stroke-width:2px
    style Inner fill:#0f0f23,stroke:#06b6d4,stroke-width:2px
    style H fill:#f59e0b,stroke:#f59e0b,color:#000,stroke-width:3px
    style Next fill:#10b981,stroke:#10b981,color:#000
```

The **inner cell** and **outer cell** are independent workflow regions that operate in parallel â€” potentially across different depth layers (Z) and different behavioral phases (W). They connect only at **event horizon** nodes: synchronization points where all cells must converge before the flow can proceed.

### Dimensional progression

Flows naturally escalate through dimensions as they gain complexity:

```mermaid actions={false}
graph LR
    subgraph D2["2D â€” Flat Flow (X Ã— Y)"]
        a1["A"] --> b1["B"] --> c1["C"]
        a1 --> d1["D"] --> c1
    end
    subgraph D3["3D â€” Mesh Helix (X Ã— Y Ã— Z)"]
        a2["Agent Î±"] <-.-> b2["Agent Î²"]
        b2 -.->|"round 2"| a2
        a2 -->|"round 3"| out2["converged"]
    end
    subgraph D4["4D â€” Tesseract (X Ã— Y Ã— Z Ã— W)"]
        cell1["Cell W=0"] --> hz["â¬¡ Horizon"]
        cell2["Cell W=1"] --> hz
        hz --> cell3["Cell W=2"]
    end
    D2 -->|"add cycles"| D3
    D3 -->|"add phases"| D4
```

### Event horizons

An event horizon is a node where multiple tesseract cells collapse into a single output. It is the 4D equivalent of a join node, but with richer semantics:

- **All cells must reach the horizon** before the flow continues â€” it is a hard synchronization barrier
- **Phase transitions happen at horizons** â€” the W coordinate shifts (e.g., from "exploration" to "refinement")
- **Depth resets at horizons** â€” completed iteration rounds crystallize into a single state (Z folds)
- **Context merges** â€” accumulated state from all cells is unified into a shared context

This is fundamentally different from a simple parallel join. A join waits for branches. An event horizon synchronizes across dimensions, triggers phase transitions, and controls how accumulated state from different depths and phases merges.

### Why this matters for AI workflows

Consider a complex research pipeline:

**Cell A (Outer â€” Exploration):** Three research agents independently search different domains, iterating with a supervisor (Z=0..3, mesh refinement). Phase W=0 (exploring).

**Cell B (Inner â€” Analysis):** Two analyst agents debate findings from a previous run, refining their synthesis (Z=0..2, convergent mesh). Phase W=1 (already refining from prior data).

```mermaid actions={false}
graph TD
    subgraph CellA["â—» Cell A â€” W=0 Exploration"]
        R1["ğŸ” Research 1"] <-.-> S["ğŸ‘ Supervisor"]
        R2["ğŸ” Research 2"] <-.-> S
        R3["ğŸ” Research 3"] <-.-> S
        S -.->|"Z=0..3\niterate"| R1
    end
    subgraph CellB["â—» Cell B â€” W=1 Analysis"]
        An1["ğŸ§  Analyst 1"] <-.->|"debate\nZ=0..2"| An2["ğŸ§  Analyst 2"]
    end
    S --> EH{"â¬¡ Event Horizon\nmerge: synthesize"}
    An2 --> EH
    EH -->|"W â†’ 2"| Conv["âœ¦ Convergence Cell\nAll agents unified"]
    style CellA fill:#1a1a2e,stroke:#8b5cf6,stroke-width:2px
    style CellB fill:#0f0f23,stroke:#06b6d4,stroke-width:2px
    style EH fill:#f59e0b,stroke:#f59e0b,color:#000,stroke-width:3px
    style Conv fill:#10b981,stroke:#10b981,color:#000
```

These cells work independently â€” different topics, different models, different iteration depths. At the **event horizon**, their outputs merge: the research feeds the analysts, the analysis redirects the researchers, and the combined system transitions from W=1 to W=2 (convergence phase) where all agents work toward a single unified output.

No other automation platform can represent this. It requires reasoning about time (iteration depth), behavioral mode (phase), and spatial independence (parallel cells) â€” all simultaneously.

### Implementation: how it compiles

The Conductor treats each tesseract cell as an independent sub-strategy:

```typescript
interface TesseractCell {
  id: string;
  phase: number;          // W coordinate â€” behavioral mode
  depthRange: [number, number]; // Z range â€” iteration bounds
  subgraph: FlowGraph;    // The 2D flow within this cell
  strategy: ExecutionStrategy;  // Pre-compiled strategy for this cell
}

interface EventHorizon {
  id: string;
  cellIds: string[];      // Which cells converge here
  mergePolicy: 'concat' | 'synthesize' | 'vote' | 'last-wins';
  phaseTransition?: number; // New W value after horizon
}

interface TesseractStrategy {
  cells: TesseractCell[];
  horizons: EventHorizon[];
  // Cells between horizons run as concurrent Promise.all groups
  // Horizons are sequential barriers
}
```

Execution:
1. All cells before the first event horizon run concurrently (`Promise.all`)
2. Each cell executes its own compiled strategy (Collapse, Extract, Parallelize, Converge all apply within cells)
3. At the event horizon, execution pauses â€” all cells must complete
4. Context merges according to the horizon's merge policy
5. Phase transitions apply (W increments)
6. Cells after the horizon execute with the merged context

```mermaid actions={false}
sequenceDiagram
    participant Conductor
    participant CellA as Cell A (W=0)
    participant CellB as Cell B (W=1)
    participant Horizon as â¬¡ Event Horizon
    participant CellC as Cell C (W=2)

    Conductor->>CellA: Promise.all â€” launch
    Conductor->>CellB: Promise.all â€” launch
    Note over CellA: Collapse + Parallelize<br/>within cell (Z=0..3)
    Note over CellB: Converge mesh<br/>within cell (Z=0..2)
    CellA-->>Horizon: output (exploration)
    CellB-->>Horizon: output (analysis)
    Note over Horizon: Merge policy: synthesize<br/>Phase transition: W â†’ 2
    Horizon->>CellC: merged context
    Note over CellC: All agents unified<br/>convergence phase
```

This is the natural extension of the Conductor's existing architecture. Parallelize already runs independent branches concurrently. Converge already handles iterative depth. The Tesseract simply makes these dimensions first-class and adds the event horizon as a synchronization primitive.

### Mapping to Conductor primitives

| Primitive | 2D role | 4D role |
|-----------|---------|---------|
| **Collapse** | Merge adjacent agent chains | Merge chains *within a cell* |
| **Extract** | Bypass LLM for deterministic nodes | Same â€” applies within cells |
| **Parallelize** | Run branches concurrently | Run *cells* concurrently |
| **Converge** | Iterate mesh until stable | Iterate within a cell (Z) |
| **Tesseract** | â€” | Orchestrate cells across phase (W) and depth (Z), sync at horizons |

### Visualization: progressive disclosure

The canvas uses **progressive disclosure** to avoid overwhelming users:

1. **Default (2D):** Standard flat canvas â€” most users never need more
2. **Mesh lift (3D):** When a convergent mesh iterates, a depth indicator shows Z layers â€” the "helix view"
3. **Tesseract (4D):** When a flow contains event horizons and parallel cells, a Schlegel overlay renders the cube-in-cube with phase rings and horizon markers

The Schlegel projection shows:
- **Outer rectangle:** The current phase cell
- **Inner rectangle:** Nested or parallel-phase cells
- **Corner lines:** Phase transition edges (W-axis connections)
- **Horizon ring:** A glowing ring at the convergence point where cells meet
- **Phase badge:** Small label showing the current W value for each cell

---

## Execution Strategy

The Conductor compiles all five primitives into a unified `ExecutionStrategy`:

```typescript
interface ExecutionStrategy {
  graphId: string;
  phases: ExecutionPhase[];        // sequential phases
  totalNodes: number;
  estimatedLlmCalls: number;       // after collapse + extract
  estimatedDirectActions: number;  // extracted nodes
  conductorUsed: boolean;
  meta: {
    collapseGroups: number;        // chains merged
    parallelPhases: number;        // phases with >1 concurrent unit
    meshCount: number;             // convergent meshes
    extractedNodes: number;        // nodes bypassing LLM
    tesseractCells: number;        // hyper-dimensional cells
  };
}

interface ExecutionPhase {
  index: number;
  units: ExecutionUnit[];          // all units in a phase run concurrently
}

interface ExecutionUnit {
  id: string;
  type: 'collapsed-agent' | 'direct-action' | 'single-agent' | 'single-direct' | 'mesh' | 'tesseract';
  nodeIds: string[];               // original nodes this unit represents
  mergedPrompt?: string;           // for collapsed units
  maxIterations?: number;          // for mesh units
  cells?: TesseractCell[];         // for tesseract units
  horizons?: EventHorizon[];       // for tesseract units
  dependsOn: string[];             // inter-unit dependencies
}
```

The strategy is computed once before execution begins. The executor then walks phases sequentially, running all units within each phase concurrently via `Promise.all`. If strategy execution fails for any reason, the executor automatically falls back to sequential node-by-node execution â€” the Conductor is always additive, never destructive.

---

## Adaptive Activation

The Conductor doesn't blindly compile every flow. Small, simple flows run faster with direct sequential execution. The `shouldUseConductor()` function evaluates whether compilation overhead is worthwhile:

| Condition | Threshold |
|-----------|-----------|
| Node count | â‰¥ 4 nodes |
| Branching | Any node with fan-out > 1 |
| Cycles | Any bidirectional edges |
| Mixed types | Both agent and direct-action nodes present |

A 3-node linear flow (trigger â†’ agent â†’ output) skips the Conductor and runs sequentially. A 6-node flow with branches, tool calls, and an agent chain activates the Conductor. The crossover point is approximately 4 nodes â€” below that, compilation overhead exceeds the savings.

---

## Performance

Benchmarks comparing sequential DAG walk (n8n/Zapier model) against Conductor-compiled execution:

| Flow Pattern | Nodes | Sequential | Conductor | Speedup | LLM Calls Saved |
|-------------|-------|------------|-----------|---------|-----------------|
| Linear chain (3 agents) | 5 | 20â€“45s | 4â€“9s | **4â€“5Ã—** | 2 (collapse) |
| Fan-out (parallel branches) | 8 | 35â€“70s | 5â€“10s | **5â€“7Ã—** | 3 (collapse + parallel) |
| Bidirectional debate | 6 | âˆ (impossible) | 15â€“25s | **âˆ** | N/A (new capability) |
| Production pipeline | 20 | 80â€“160s | 8â€“18s | **8â€“10Ã—** | 12+ (all primitives) |
| Tesseract research pipeline | 12 | âˆ (impossible) | 20â€“40s | **âˆ** | N/A (new capability) |

The gains compound: Collapse reduces total LLM calls, Extract eliminates unnecessary ones, and Parallelize runs the remaining work concurrently. On a 20-node production flow, the Conductor can reduce wall-clock time by an order of magnitude.

---

## vs. Every Other Platform

| Capability | n8n | Zapier | Make | Airflow | OpenPawz Conductor |
|-----------|-----|--------|------|---------|--------------------|
| **Execution model** | Sequential DAG walk | Sequential DAG walk | Sequential DAG walk | Task scheduler (DAG) | AI-compiled strategy |
| **Cycles / feedback loops** | Error | Error | Error | Error | Convergent Mesh |
| **Agent-as-node** | Via HTTP/code wrapper | Via HTTP wrapper | Via HTTP wrapper | External operator | First-class, streaming |
| **LLM call optimization** | None | None | None | None | Collapse (N agents â†’ 1 call) |
| **Deterministic bypass** | All nodes same path | All nodes same path | All nodes same path | All nodes same path | Extract (skip LLM) |
| **Auto-parallelism** | Manual split/merge | None | Manual router | Executor-level | Automatic depth analysis |
| **Bidirectional edges** | No | No | No | No | Yes (forward, reverse, bidirectional, error) |
| **Debug step-through** | Limited | None | Limited | Log-based | Full breakpoints + cursor + edge inspection |
| **Self-healing** | No | Retry only | Retry only | Retry only | Error diagnosis + fix proposals + auto-retry |
| **Memory integration** | No | No | No | No | Memory-write/recall nodes |
| **Multi-agent teams** | No | No | No | No | Squad nodes |
| **4D hyper-dimensional flows** | No | No | No | No | Tesseract cells + event horizons |
| **Cost** | Self-hosted free / Cloud paid | Per-task pricing | Per-operation pricing | Self-hosted free | Free local (Ollama) or cloud |

### The fundamental difference

Traditional platforms treat workflows as **imperative programs** â€” a fixed sequence of steps the computer follows literally. The Conductor treats workflows as **declarative blueprints** â€” a description of what needs to happen, which the system compiles into the most efficient execution plan.

This is the same conceptual leap that separated SQL from procedural database queries, or that separated React's declarative UI from imperative DOM manipulation. You describe *what*, not *how*. The runtime figures out *how*.

---

## Edge Types

The Conductor's power partly comes from OpenPawz's four edge types â€” richer than any other workflow platform:

| Edge Kind | Direction | Purpose | Enables |
|-----------|-----------|---------|---------|
| **Forward** | A â†’ B | Normal data flow | Standard pipelines |
| **Reverse** | A â† B | Data pull â€” B requests from A | Lazy evaluation, on-demand data |
| **Bidirectional** | A â†” B | Handshake â€” mutual data exchange | Cycles, debates, iterative refinement |
| **Error** | A --errâ†’ B | Failure routing | Graceful degradation, fallback chains |

n8n, Zapier, and Make support only forward edges. Airflow supports forward edges with limited error handling. OpenPawz's reverse and bidirectional edges enable entirely new workflow patterns that are structurally impossible on other platforms.

---

## Debug Mode

The Conductor includes a full step-through debugger â€” uncommon in workflow platforms and absent from automation tools like Zapier and Make:

- **Breakpoints**: Click any node to set a breakpoint. Execution pauses when the Conductor reaches that node.
- **Step-through**: Execute one node at a time, inspecting inputs and outputs at each step.
- **Edge data inspection**: See the actual data flowing through each edge during execution (truncated to 80 characters for readability).
- **Cursor tracking**: A visual cursor follows execution across the canvas, highlighting the currently executing node.
- **Pause/Resume/Abort**: Full lifecycle control during any execution â€” sequential or Conductor-compiled.

Debug mode works with both sequential and Conductor-compiled execution. When debugging a Conductor strategy, the debugger steps through execution units within phases, showing collapsed units as single steps and expanding mesh iterations.

---

## Self-Healing

When a node fails during execution, the Conductor doesn't just retry blindly. The self-healing system:

1. **Classifies the error** into categories: timeout, rate-limit, auth, network, invalid-input, config, code-error, api-error
2. **Generates a diagnosis** explaining what went wrong and why
3. **Proposes fixes** with confidence scores â€” e.g., "increase timeout to 60s (confidence: 0.85)" or "check API key in vault (confidence: 0.92)"
4. **Retries with backoff** â€” configurable max retries, delay, and exponential backoff
5. **Routes to error handlers** â€” if retry fails, error edges route to designated error-handler nodes, and the success-path subtree is skipped

This turns brittle automation into resilient pipelines. A rate-limited API call doesn't crash the flow â€” it backs off, retries, and if it still fails, routes to a fallback path.

---

## The Trinity

The Conductor Protocol is the third of OpenPawz's three complementary inventions. Together, they solve the complete lifecycle of AI-driven automation:

| Protocol | Problem | Solution |
|----------|---------|----------|
| [**The Librarian Method**](/reference/librarian-method) | *Which* tool to use among many? | Intent-driven discovery via semantic embeddings |
| [**The Foreman Protocol**](/reference/foreman-protocol) | *How* to execute tools cheaply? | Worker model delegation via self-describing MCP |
| **The Conductor Protocol** | *What's the optimal execution plan?* | AI-compiled flow strategies: Collapse, Extract, Parallelize, Converge, Tesseract |

In a single flow execution:
1. The **Conductor** compiles the graph into an optimized strategy â€” collapsing agents, extracting direct actions, parallelizing branches
2. Agent nodes that need tools use the **Librarian** to discover which workflows/tools are relevant
3. Tool calls are delegated to the **Foreman** for cheap or free execution via worker models

The result: a 20-node flow that would take 2+ minutes on n8n executes in under 20 seconds on OpenPawz, with lower cost and capabilities (cycles, memory, squads) that other platforms cannot express at all.

---

## 25,000 Nodes, Reimagined

n8n has over 25,000 community-contributed integration nodes â€” Slack, Jira, GitHub, Stripe, Airtable, Google Sheets, thousands more. Every one of them was designed for the same paradigm: a human drags nodes onto a canvas, manually wires them together, and builds a sequential automation. The nodes are powerful. The paradigm is limited.

The Conductor Protocol transforms what those nodes can do.

n8n's MCP server exposes workflow-level tools: `search_workflows`, `execute_workflow`, and `get_workflow_details`. Paw composes n8n nodes into per-service workflows that are auto-deployed and made available through MCP. The Conductor can then orchestrate these workflows as part of larger, AI-compiled execution strategies:

- **Collapse** multiple sequential workflow executions into a single orchestrated call
- **Extract** simple workflow executions and run them directly â€” no LLM reasoning needed
- **Parallelize** independent workflow executions across branches automatically
- **Converge** workflow-connected agents in iterative feedback loops that n8n itself cannot express

This is not a wrapper around n8n. It is a fundamentally new execution model that uses n8n's integration ecosystem as building blocks for AI-compiled workflows.

### What this means in practice

A user types:

> *"When a webhook fires, have an agent classify the data, then in parallel: summarize it and store it in Airtable, and if it's urgent, post to Slack #alerts"*

The NLP parser builds a 7-node flow graph. The Conductor compiles it:

- **Phase 0:** Trigger (passthrough)
- **Phase 1:** Agent classify (single LLM call)
- **Phase 2:** Agent summarize â€– Airtable store â€– Condition check â€” all concurrent
- **Phase 3:** Slack post (direct, no LLM)

The Airtable and Slack operations are n8n workflows executed via `execute_workflow`. They execute via Extract â€” direct MCP calls, zero LLM cost. The agent steps that need AI intelligence get Collapsed where possible. Independent branches Parallelize automatically.

The 25,000 n8n nodes didn't change. What changed is the engine that orchestrates them â€” and the fact that Paw composes those nodes into workflows that become first-class tools.

---

## Natural Language to Compiled Flow

Traditional workflow platforms require users to manually construct automations â€” drag nodes, configure each one, wire connections. The Conductor Protocol sits at the end of a pipeline that eliminates this entirely:

```mermaid actions={false}
graph LR
    A["User types: 'webhook â†’ agent â†’ send email'"] --> B["NLP Parser"]
    B --> C["Flow Graph"]
    C --> D["Conductor Compiler"]
    D --> E["Execution Strategy"]
    E --> F["Optimized Execution"]
```

1. **Natural language input** â€” The user describes a workflow in plain English in the Flows text box
2. **NLP parsing** â€” The text-to-flow parser identifies node types, relationships, and configurations from the description
3. **Graph construction** â€” A complete `FlowGraph` is built with nodes, edges, positions, and default configurations
4. **Conductor compilation** â€” The graph is analyzed and compiled into an optimized `ExecutionStrategy`
5. **Execution** â€” The strategy runs with all five primitives applied

The entire path from "I want a webhook that classifies incoming data and posts urgent items to Slack" to compiled, optimized, executing flow happens without the user ever dragging a node or wiring a connection.

This collapses the gap between **intent** and **execution** in a way no other platform achieves. Zapier requires manual Zap construction. n8n requires manual node wiring. Make requires manual scenario building. Even AI-assisted tools like Zapier's AI only help *configure* individual steps â€” they don't compile the execution.

The Conductor compiles. That is the difference.

---

## Implementation

The Conductor Protocol is implemented in TypeScript as part of the OpenPawz flow engine:

| Module | Purpose |
|--------|---------|
| `conductor-atoms.ts` | Core types â€” `ExecutionStrategy`, `ExecutionPhase`, `ExecutionUnit`, `shouldUseConductor()` |
| `conductor-graph.ts` | Graph analysis â€” `classifyNode()`, `computeDepths()`, `findCycles()` |
| `conductor-collapse.ts` | Collapse primitive â€” `detectCollapseChains()`, `buildCollapsedPrompt()`, `parseCollapsedOutput()` |
| `conductor-parallel.ts` | Parallelize primitive â€” `groupByDepth()`, `splitIntoIndependentGroups()` (union-find) |
| `executor-conductor.ts` | Strategy execution â€” `runConductorStrategy()`, `executeCollapsedUnit()`, `executeMeshRounds()` |
| `executor.ts` | Main executor â€” `createFlowExecutor()`, sequential fallback |
| `executor-debug.ts` | Debug mode â€” breakpoints, step-through, edge inspection |
| `executor-handlers.ts` | Node handlers â€” HTTP, MCP, Squad, Memory, Loop execution |
| `self-healing-atoms.ts` | Error classification, diagnosis, fix proposals |

### Strategy compilation (simplified)

```typescript
function compileStrategy(graph: FlowGraph): ExecutionStrategy {
  // 1. Classify every node
  const classifications = graph.nodes.map(n => classifyNode(n));

  // 2. Detect collapsible agent chains
  const collapseGroups = detectCollapseChains(graph);

  // 3. Detect convergent meshes (cyclic subgraphs)
  const meshes = buildMeshConfigs(graph);

  // 4. Compute depth levels for parallelization
  const depths = groupByDepth(graph, collapseGroups, meshes);

  // 5. Split each depth level into independent groups
  const phases = depths.map(level => ({
    units: splitIntoIndependentGroups(level)
  }));

  return {
    phases,
    estimatedLlmCalls: countAgentUnits(phases),
    estimatedDirectActions: countDirectUnits(phases),
    conductorUsed: true,
    meta: { collapseGroups: collapseGroups.length, ... }
  };
}
```

### Strategy execution

```typescript
async function runConductorStrategy(strategy: ExecutionStrategy) {
  for (const phase of strategy.phases) {
    // All units within a phase run concurrently
    await Promise.all(phase.units.map(unit => {
      switch (unit.type) {
        case 'collapsed-agent':
          return executeCollapsedUnit(unit);   // 1 LLM call for N nodes
        case 'direct-action':
          return executeDirectAction(unit);    // No LLM â€” Rust/sandbox
        case 'single-agent':
          return executeAgentStep(unit);        // 1 LLM call
        case 'mesh':
          return executeMeshRounds(unit);       // Iterative convergence
      }
    }));
  }
}
```

---

## Try It

### Build a flow

1. Open **Flows** from the sidebar
2. Click **+** to create a new flow, or describe one in the text box: *"webhook â†’ agent summarize â†’ agent format â†’ send email"*
3. The NLP parser builds the graph automatically

### See the Conductor in action

1. Build a flow with 4+ nodes including at least one branch
2. Click **Run** (â–¶) â€” the Conductor compiles a strategy and executes it
3. Watch nodes light up in parallel when independent branches execute concurrently
4. After execution, the strategy is available via `getLastStrategy()` for inspection

### Debug step-through

1. Click **Debug** (ğŸ›) to enter debug mode
2. Click any node to set a breakpoint
3. Click **Step** (â­) to advance one node at a time
4. Inspect edge data labels to see values flowing through the graph

### Try a convergent mesh

1. Create two agent nodes
2. Connect them with a **bidirectional** edge (drag while holding Shift, or select bidirectional from edge type)
3. Add an output node downstream
4. Run â€” watch the agents iterate until convergence

### Try a tesseract flow

1. Open **Flows** and create a new flow
2. Add several agent nodes across two logical groups (e.g., "research" agents and "analysis" agents)
3. Add an **event-horizon** node from the toolbar (â¬¡ button)
4. Connect both groups into the event horizon
5. Add an output node after the horizon
6. Run â€” watch cells execute concurrently, then converge at the horizon with a phase transition
7. The Schlegel overlay appears automatically, showing the cube-in-cube projection with phase-colored borders

Or describe it in natural language:

> *"three research agents explore in parallel, two analysts debate findings, event horizon merges into final synthesis"*

---

## License & Attribution

The Conductor Protocol is part of **OpenPawz** and is released under the **MIT License**. You are free to use, modify, and redistribute this technique in any project, commercial or otherwise. Attribution is appreciated but not required.

If you reference this work in academic papers or technical writing:

> OpenPawz (2025). "The Conductor Protocol: AI-Compiled Flow Execution via Collapse, Extract, Parallelize, Converge, and Tesseract." https://github.com/OpenPawz/openpawz
